# Параллельное программирование в GO

## Горутины

Горутины (goroutines) представляют параллельные операции, которые могут выполняться независимо от функции, в которой они запущены

EX: `go StupidGorutine(i)`
Горутины запускаются независимо то main, которя тоже горутина, если main завершится какой-то горутины, то мы не увидем результат.

## Каналы

Каналы (channels) представляют инструменты коммуникации между горутинами. Для определения канала применяется ключевое слово chan:

#### Небуферизированные каналы

EX1: `var intCh chan int // канал в который передается int`

EX2: `strCh := make(chan string)  // канал для данных типа string`
Если канал пустой, горутина-получатель блокируется до появления данных.
Когда горутина-отправитель отправляет данные, получатель их получает и продолжает работу.
Горутина-отправитель может отправлять данные только в пустой канал и блокируется до их получения.

#### Буферизированные каналы

Буферизированные каналы также создаются с помощью функции make(), только в качестве второго аргумента в функцию передается емкость канала. Если канал пуст, то получатель ждет, пока в канале появится хотя бы один элемент.

```Go
func main() {

    intCh := make(chan int, 3)
    intCh <- 10
    intCh <- 3
    intCh <- 24
    intCh <- 15  // блокировка - функция main ждет, когда освободится место в канале

    fmt.Println(<-intCh)
    fmt.Println("The End")
}
```

#### Однонаправленные каналы

В Go можно определить канал, как доступный только для отправки данных или только для получения данных.

`var inCh chan<- int` - определение канала только для отправки
`var inCh <-chan int` - определение канала только для получения

Также канал можно возвращать из функции, однако стоит быть аккуртным, может произойти deadlock. Запись в горутине, стоит обернуть в лямбду

#### Закрытие канала

После инициализации канал готов передавать данные. Он находится в открытом состоянии, и мы можем с ним взаимодействовать, пока не будет закрыт с помощью встроенной функции `close()`

```Go
func main() {
    intCh := make(chan int, 3)
    intCh <- 10
    intCh <- 3
    close(intCh)    // канал закрыт

    for i := 0; i < cap(intCh); i++ {
         if val, opened := <-intCh; opened {
            fmt.Println(val)
         } else {
            fmt.Println("Channel closed!")
         }
   }
}
/* stdout:
10
3
Channel closed!
*/
```

#### Синхронизация

Использование каналов открывает нам возможности по синхронизации между различными горутинами.
Канал не обязательно должен нести данные `structCh := make(chan struct{})`
Иногда это может быть холостой объект, например, пустая структура, которая необходима только для синхронизации горутин

#### Передача потоков данных

Нередко одна горутина транслирует другой горутине через канал не одиночные значения, а некоторый поток данных. В этом случае общий алгоритм состоит в том, что горутина-отправитель в течение некоторого периода отправляет данные. Когда данные для отправки закончились, работа сделала, отправитель закрывает канал.

## sync.Mutex

Мьютексы в go лежат по пакете `sync`
На уровне кода мьютекс представляет тип sync.Mutex. Для блокирования доступа к общему разделяемому ресурсу у мьютекса вызывается метод `Lock()`, а для разблокировки доступа - метод `Unlock()`.

```Go
func work (number int, ch chan bool, mutex *sync.Mutex){
    mutex.Lock()    // блокируем доступ к переменной counter
    counter = 0
    for k := 1; k <= 5; k++{
        counter++
        fmt.Println("Goroutine", number, "-", counter)
    }
    mutex.Unlock()  // деблокируем доступ
    ch <- true
}
```

## sync.WaitGroup

Позволяет определить группу горутин, которые должны выполняться вместе как одна группа. И можно установить блокировку, которая приостановит выполнение функции, пока не завершит выполнение вся группа горутин.

```Go
package main

import (
	"fmt"
	"sync"
	"time"
)


func main() {
    var wg sync.WaitGroup
    wg.Add(2)       // в группе две горутины
    work := func(id int) {
        defer wg.Done()
        fmt.Printf("Горутина %d начала выполнение \n", id)
        time.Sleep(2 * time.Second)
        fmt.Printf("Горутина %d завершила выполнение \n", id)
   }

   // вызываем горутины
   go work(1)
   go work(2)

   wg.Wait()        // ожидаем завершения обоих горутин
   fmt.Println("Горутины завершили выполнение")
}
```
